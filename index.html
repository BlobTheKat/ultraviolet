<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Ultraviolet</title>
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@800&display=swap');
	</style>
	<script src="https://picfunk.art/codearea.js"></script>
	<style>
		*{ box-sizing: border-box; text-size-adjust: none; }
		html{
			background: linear-gradient(70deg, #05a -100%, #70a 100%);
			min-height: 100%; display: flex; flex-direction: column;
			padding: 16px;
			padding-top: 158px;
		}
		body{
			margin: 0;
			border-radius: 0 0 16px 16px;
			background: #000a;
			color: #ddd; padding: 16px; font: 400 16px Arial;
			line-height: 24px;
			user-select: none;
		}
		h1{
			position: absolute; top: 0; left: 0; width: 100%;
			color: #eee; font: 900 40px 'Roboto Slab', Arial;
			padding: 50px; margin: 0;
			line-height: 50px;
			background: #fff4;
			clip-path: polygon(0 0, 100% 0, 100% 80%, 0 100%);
		}
		h1 > b{color:#000}
		c{
			font-family: Consolas, monospace;
			padding: 0 2px; background: #fff3; border-radius: 6px;
			user-select: all; font-weight: 700;
		}
		k{
			font-family: Consolas, monospace;
			padding: 0 2px; background: #fff3; border-radius: 6px; padding: 4px;
			font-weight: 700;
			display: block;
			margin-top: 8px;
		}
		k t{ color: #c4f }
		k n{ color: #e52 }
		k m{ color: #dd8 }
		k d{ color: #bbf }
		hr{ border: none; height: 2px; background: #fff5; margin: 1em 0 }
		[refto]{ text-decoration: underline; cursor: pointer }
		#docs{ padding-top: 16px }
		#docs > div{ display: none }
		#docs > h2{ margin: 0; font-family: Consolas, monospace; cursor: pointer; text-decoration: underline; }
		#docs > h2:not(#docsselected){ opacity: .5; font-size: 16px }
		code-area{
			font-family: Consolas, monospace;
			padding: 4px; background: #fff3; border-radius: 6px;
		}
		::selection{background:#8888}
		nav{
			flex-wrap: wrap; gap: 1px;
			border-radius: 16px 16px 0 0;
			color: #ddd; font: 700 16px Arial;
			user-select: none;
			margin-bottom: 1px;
			display: flex;
			font-size: 0.9em;
			overflow: clip;
			flex-shrink: 0;
		}
		nav > div{
			background: #000a;
			flex: 1 1px; cursor: pointer;
			height: 30px; line-height: 30px;
			text-align: center;
			-webkit-tap-highlight-color: #0000;
		}
		@media screen and (max-width: 470px) { nav > div{ min-width: 49%; } }
		#selected{
			background: #fff; color: black;
		}
		iframe{
			width: 100%; outline: none;
			border: none; border-top: 1px #fff8 solid;
			border-radius: 0 0 6px 6px;
			aspect-ratio: 1/1; max-height: 400px;
			background: #000;
		}
		#sandbox{ border-radius: 6px 6px 0 0; max-height: 525px; overflow: auto; }
		::-webkit-scrollbar{width:0}
		li{margin:.5em 0}
	</style>
</head>
<h1><b>u</b>ltra<b>v</b>iolet</h1>
<nav>
	<div id="selected" node="gettingStarted">Getting started</div>
	<div node="features">Features</div>
	<div node="docs">Docs</div>
	<div onclick="window.open('https://github.com/BlobTheKat/ultraviolet','_blank')">Contribute</div>
</nav>
<div id="gettingStarted">
	Super Epic 2D graphics library backed by <c>WebGL2</c><br><br>
	<code-area lang="html" disabled>
&lt;script src='https://ultraviolet.js.org/uv.min.js'>&lt;/script>
&lt;canvas width='500' height='300' id='canvas'>&lt;/canvas>
&lt;script>
const ctx = setTargetCanvas(document.getElementById('canvas'))
// ...
&lt;/script>
	</code-area><br>
	This library exposes drawing functionalities much like OpenGL: Build meshes and draw them with GLSL shaders<br>
	At the same time making best use of JS paradigm and APIs<br><br>
	<code-area lang="js" id="sandbox">
// autoCanvas() is a convenience function to replace setTargetCanvas()
// Make sure to call it before anything else
const ctx = autoCanvas(everyFrame)

const cat = Texture().fromSrc('./sample.png')

let rot = 0
function everyFrame(width, height, dt){
	rot += dt
	// Edit me!
	ctx.translate(width/2, height/2)
	const mesh = makeCatpheus(160 + Math.sin(rot*4)*10, rot)
	ctx.draw(mesh, cat)
	drawParticles(ctx.sub(), height, dt)
}

// You can create one mesh ahead of time and pre-upload it for increased performance
// const mesh = makeCatpheus().upload()
function makeCatpheus(rad = 170, rot = 0){
	const msh = Mesh()
	msh.rotate(rot)
	msh.addRect(-100, -100, 200, 200)
	msh.rotate(-rot*2)
	for(let i = 0; i &lt; 16; i++){
		const wave = Math.sin((PI2*(i/16) - rot)*5)*15
		// addRect(x, y, width, height, uv, effect, tint_r, tint_g, tint_b, tint_a)
		// Here we imagine the image to be broken into a 4x4 grid
		// and we choose a sub-square based on i
		msh.addRect(-10, rad + wave, 20, 20, uv(i%4/4, Math.floor(i/4)/4, .25, .25))
		msh.rotate(PI2/16)
	}
	return msh.upload()
}

// Shaders! The particles change color as they fall
const particleShader = Shader(`void main(){
	color = texture(tex0, uv.xy);
	float x = abs(effect-.5);
	color.rgb = (color.rrr*x - color.bbb*x + color.bbb*(1.-x))*.3;
}`)
const particles = new Float32Array(100)
for(let i = 0; i &lt; particles.length; i++)
	particles[i] = Math.random()

const additiveBlend = Blend(ONE, ADD, ONE) // src*1 + dst*1
function drawParticles(subCtx, h, dt){
	const mesh = Mesh()
	subCtx.useShader(particleShader)
	// Go left
	mesh.translate(-202,0)
	let prevY = 0
	for(let i = 0; i &lt; 100; i++){
		const pos = particles[i], pos2 = pos*pos
		mesh.translate(4, -(pos2-prevY)*(h+16))
		mesh.addRect(-8, -8, 16, 16, _, (pos+i/5)%1)
		prevY = pos2
		particles[i] = (pos+dt/2)%1
	}
	subCtx.translate(0,h/2+8)
	subCtx.draw(mesh, cat, _, additiveBlend)
}
	</code-area>
	<iframe sandbox="allow-scripts" id="sandboxi"></iframe>
</div>
<div id="features" hidden>

<li>Textures & texture arrays:</li>
<code-area lang="js" disabled>
const flowerTex = Texture()
flowerTex.from(fetch('./flower.png').then(a => a.blob()))

const spriteList = Texture(16, 16, 100)
for(let i = 0; i &lt; 100; i++)
	spriteList.put(fetch(`./sprite${i}.png`).then(a => a.blob()), 0, 0, i)
</code-area><br>
<li>Many texture formats including integer textures:</li>
<code-area lang="js" disabled>
const flowerTex = Texture()
flowerTex.fromSrc('./flower.png', Formats.RGBA4)
flowerTex.fromSrc('./flower.png', Formats.RGBA565)
flowerTex.fromSrc('./flower.png', Formats.RG16F)
flowerTex.fromSrc('./flower.png', Formats.R32)
</code-area><br>
<li>Texture customization (wrap mode, filtering, mipmaps):</li>
<code-area lang="js" disabled>
flowerTex.fromSrc('./flower.png', _, PIXELATED | REPEAT)
flowerTex.options(REPEAT_X | REPEAT_MIRRORED_Y | MIPMAPS | UPSCALE_PIXELATED)
</code-area><br>
<li>Draw to other targets or textures:</li>
<code-area lang="js" disabled>
const toFlower = Target(flowerTex)
toFlower.draw(...)
ctx.draw(..., [flowerTex]) // Will render updated texture
</code-area><br>
<li>Read pixels from a target or canvas:</li>
<code-area lang="js" disabled>
function colorPicker(x, y){
	const [r, g, b, a] = ctx.getData(x, y, 1, 1)
	return {r, g, b, a}
}
</code-area><br>
<li>Canvas2D-like transformations (`.translate()`, `.scale()`, `.rotate()`, ...):</li>
<code-area lang="js" disabled>
ctx.translate(ctx.width/2, ctx.height/2)
ctx.rotate(PI/2)
ctx.scale(2)
ctx.draw(...)
</code-area><br>
<li>GLSL Shaders:</li>
<code-area lang="js" disabled>
const sh = Shader(`void main(){
	color = texture(tex0, uv.xy);
	if(color.a &lt; .5) discard;
}`)
ctx.useShader(sh)
</code-area><br>
<li>Meshes, allowing fast bulk-drawing of thousands or millions of sprites:</li>
<code-area lang="js" disabled>
function makeMesh(){
	const msh = Mesh()
	msh.scale(10)
	msh.addRect(...)
	msh.addRect(...)
	for(let i = 0; i &lt; 1_000_000; i++) msh.addRect(...)
	return msh.upload()
}
const bigMesh = makeMesh()
function everyFrame(){
	ctx.draw(bigMesh, flowerTex)
}
</code-area><br>
<li>Custom-use sprite properties (for use within shaders):</li>
<code-area lang="js" disabled>
const sh = Shader(`void main(){
	// tint is one such custom-use property
	color = texture(tex0, uv.xy) * tint;
}`)
ctx.useShader(sh)
const msh = Mesh()
const tint = [1, 0, 0, 1]
msh.addRect(0, 0, 100, 100, _, _, tint[0], tint[1], tint[2], tint[3])
...

ctx.draw(msh, flowerTex)
</code-area><br>
<li>Mesh export/importing:</li>
<code-area lang="js" disabled>
// Let's send the mesh to a web worker to do some processing in parallel
const f32arr = msh.export()
worker.postMessage(f32arr)
worker.onmessage = ({data}) => {
	const msh = Mesh()
	msh.import(data)
	// Work is done, let's draw!
}
</code-area><br>
<li>Stencil buffer access for clipping:</li>
<code-area lang="js" disabled>
ctx.draw(clipShape, _, DONT_DRAW | SET_ONE)
// New mesh will only be drawn where it would intersect with clipShape
ctx.draw(mesh, _, RGBA | IF_ZERO)
</code-area><br>
<li>Customizable blend algorithms:</li>
<code-area lang="js" disabled>
// dst = src*(1-dst.a) + dst*1
const additiveBlendBehind = Blend(ONE_MINUS_DST_ALPHA, ADD, ONE)
ctx.draw(mesh, flowerTex, RGBA, additiveBlendBehind)
// or a prebuilt one
ctx.draw(mesh, flowerTex, RGBA, Blend.REPLACE)
</code-area><br>
<li>8 textures and 6 uniforms per draw operation:</li>
<code-area lang="js" disabled>
ctx.setU(1, 2, 3, 4) // accessible as `uniform vec4 u;` in shader
ctx.setST(5, 6) // accessible as `uniform float s, t;` in shader

// Textures available as tex0,tex1,...,tex7 in shader
// Access integer textures with utex0...utex7 & array textures with atex0...atex7
// If your shader uses a specific type make sure to pass the correct one in .draw()!
ctx.draw(mesh, [tex0, tex1, tex2, tex3, tex4, tex5, tex6, tex7])
</code-area><br>
Thank you for coming to my TED talk.

</div>
<div id="docs" hidden>
	<h2 refto="exports">Module exports</h2>
	<h2 refto="constants">Constants</h2>
	<h2 refto="texture">Texture (wip)</h2>
	<h2 refto="uv">UV</h2>
	<h2 refto="mesh">Mesh (wip)</h2>
	<h2 refto="target">Target (wip)</h2>
	<h2 refto="transformable">Transformable (wip)</h2>
	<h2 refto="shader">Shader (wip)</h2>
	<h2 refto="blend">Blend (wip)</h2>
	<hr>
	<div id="exports">
		Sets the canvas to initialise the drawing context from.<br>
		You must call this or <c>autoCanvas()</c> before making use of any other function or method
		<k><m>setTargetCanvas</m>(canvas: <t>HTMLCanvasElement</t>) -> <t refto="target">Target</t></k>
		<hr>
		Creates a new canvas and appends it to the body.<br>
		Automatically resizes the canvas to fit the screen and transforms it to CSS-pixel space for you<br>
		Will call the function <c>renderFn</c> every frame, with the canvas's width/height in CSS-pixel units, as well as the seconds passed since the last frame in <c>dt</c><br>
		You must call this or <c>setTargetCanvas()</c> before making use of any other function or method
		<k><m>autoCanvas</m>(renderFn: (width: <t>number</t>, height: <t>number</t>, dt: <t>number</t>) => <t>void</t>) -> <t refto="target">Target</t></k>
		<hr>
		Construct a new uninitialised texture object. See <b refto="texture">its section</b> for more information.
		<k><m>Texture</m>(width?: <t>int</t>, height?: <t>int</t>, layers?: <t>int</t>, format?: <n>valueof</n> <t refto="constants">Formats</t>, options?: <t refto="texture">TextureOptions</t>) -> <t refto="texture">Texture</t></k>
		<hr>
		Construct a new mesh. See <b refto="mesh">its section</b> for more information.
		<k><m>Mesh</m>() -> <t refto="mesh">Mesh</t></k>
		<hr>
		Construct a new target from a size or texture. See <b refto="target">its section</b> for more information.
		<k><m>Target</m>(width?: <t>int</t>, height?: <t>int</t>, format?: <n>valueof</n> <t refto="constants">Formats</t>, stencil?: <t>boolean</t>) -> <t refto="target">Target</t><br>
		<m>Target</m>(texture: <t refto="texture">Texture</t>, layer?: <t>int</t>, stencil?: <t>boolean</t>) -> <t refto="target">Target</t></k>
		<hr>
		Construct a new shader from GLSL source code. See <b refto="shaders">its section</b> for more information.
		<k><m>Shader</m>(glslSource: <t>string</t>) -> <t refto="shaders">Shader</t></k>
		<hr>
		Represent a uv (A uv is a location within a texture, think a crop rectangle for a texture). See <b refto="uv">its section</b> for more information.
		<k><m>uv</m>(x?: <t>number</t>, y?: <t>number</t>, w?: <t>number</t>, h?: <t>number</t>, layer?: <t>number</t>) -> <t refto="uv">UV</t></k>
		<hr>
		Create a blend function. See <b refto="blend">its section</b> for more information.
		<k><m>Blend</m>(srcMult: <t refto="blend">BlendMultiplier</t>, combineOp: <t refto="blend">BlendCombine</t>, dstMult: <t refto="blend">BlendMultiplier</t>) -> <t refto="blend">Blend</t></k>
		<hr>
		Change the output canvas's color space. <c>display-p3</c> allows slightly more vibrant colors than <c>srgb</c>, while sacrificing equally in color precision
		<k><m>colorSpace</m>(space: <t style="color:#ea2">'srgb'</t> | <t style="color:#ea2">'display-p3'</t>)</k>
		<hr>
		<k><d>_</d> = <t>undefined</t><br><d>PI</d> = <d style="color:#ae2">3.141592653589793</d><br><d>PI2</d> = PI*<d style="color:#ae2">2</d></k><br>
		More constants are exposed as module exports, see the <b refto="constants">constants section</b>
	</div>
	<div id="constants">
		<k><d>_</d> = <t>undefined</t><br><d>PI</d> = <d style="color:#ae2">3.141592653589793</d><br><d>PI2</d> = PI*<d style="color:#ae2">2</d></k>
		<k><d>Formats</d> = {<br>
			&nbsp;&nbsp;<d style="color:#ffffff4d">// Regular 8 bit formats</d><br>
			&nbsp;&nbsp;<d>R</d>, <d>RG</d>, <d>RGB</d>, <d>RGBA</d>,<br>
			&nbsp;&nbsp;<d style="color:#ffffff4d">// Varying bits shared between different channels<br>
			&nbsp;&nbsp;// Upload data by packing into 8/16/32 bit ints</d><br>
			&nbsp;&nbsp;<d>RGB565</d>, <d>RGB5_A1</d>, <d>RGB10_A2</d>,<br>
			&nbsp;&nbsp;<d>RGBA4</d>, <d>R11F_G11F_B10F</d>, <d>RGB9_E5</d>,<br>
			&nbsp;&nbsp;<d style="color:#ffffff4d">// Integer 8, 16 and 32 bit textures</d><br>
			&nbsp;&nbsp;<d>R8</d>, <d>RG8</d>, <d>RGB8</d>, <d>RGBA8</d>,<br>
			&nbsp;&nbsp;<d>R16</d>, <d>RG16</d>, <d>RGB16</d>, <d>RGBA16</d>,<br>
			&nbsp;&nbsp;<d>R32</d>, <d>RG32</d>, <d>RGB32</d>, <d>RGBA32</d>,<br>
			&nbsp;&nbsp;<d style="color:#ffffff4d">// half-precision float textures</d><br>
			&nbsp;&nbsp;<d>R16F</d>, <d>RG16F</d>, <d>RGB16F</d>, <d>RGBA16F</d>,<br>
			&nbsp;&nbsp;<d style="color:#ffffff4d">// half-precision float textures that allow you<br>
			&nbsp;&nbsp;// to upload data with single-precision floats</d><br>
			&nbsp;&nbsp;<d>R16F_32F</d>, <d>RG16F_32F</d>, <d>RGB16F_32F</d>, <d>RGBA16F_32F</d>,<br>
			&nbsp;&nbsp;<d style="color:#ffffff4d">// single-precision float textures</d><br>
			&nbsp;&nbsp;<d>R32F</d>, <d>RG32F</d>, <d>RGB32F</d>, <d>RGBA32F</d><br>
		}</k>
		<k>
			<d style="color:#ffffff4d">// Constants used by third argument to (Target).draw()</d><br>
			<d>R</d>, <d>G</d>, <d>B</d>, <d>A</d>, <d>RGB</d> = R|G|B, <d>RGBA</d> = R|G|B|A<br>
			<d>IF_ONE</d>, <d>IF_ZERO</d>, <d>DONT_DRAW</d><br>
			<d>UNSET</d>, <d>SET</d>, <d>FLIP</d><br>
			<d>DITHERING</d><br><br>
			<d style="color:#ffffff4d">// Constants used by BlendMultiplier</d><br>
			<d>ZERO</d><br>
			<d>RGB_ONE</d>, <d>A_ONE</d><br>
			<d>ONE</d> = RGB_ONE|A_ONE</d><br>
			<d>RGB_SRC</d>, <d>A_SRC</d>, <d>SRC</d> = RGB_SRC|A_SRC<br>
			<d>RGB_ONE_MINUS_SRC</d>, <d>A_ONE_MINUS_SRC</d><br>
			<d>ONE_MINUS_SRC</d> = RGB_ONE_MINUS_SRC|A_ONE_MINUS_SRC<br>
			<d>RGB_SRC_ALPHA</d>, <d>SRC_ALPHA</d> = RGB_SRC_ALPHA|A_SRC<br>
			<d>RGB_ONE_MINUS_SRC_ALPHA</d><br>
			<d>ONE_MINUS_SRC_ALPHA</d> = RGB_ONE_MINUS_SRC_ALPHA|A_ONE_MINUS_SRC<br>
			<d>A_DST</d>, <d>RGB_DST</d>, <d>DST</d> = RGB_DST|A_DST<br>
			<d>RGB_ONE_MINUS_DST</d>, <d>A_ONE_MINUS_DST</d><br>
			<d>ONE_MINUS_DST</d> = RGB_ONE_MINUS_DST|A_ONE_MINUS_DST<br>
			<d>RGB_DST_ALPHA</d>, <d>DST_ALPHA</d> = RGB_DST_ALPHA|A_DST<br>
			<d>RGB_ONE_MINUS_DST_ALPHA</d><br>
			<d>ONE_MINUS_DST_ALPHA</d> = RGB_ONE_MINUS_DST_ALPHA|A_ONE_MINUS_DST<br>
			<d>RGB_SRC_ALPHA_SATURATE,</d><br>
			<d>SRC_ALPHA_SATURATE</d> = RGB_SRC_ALPHA_SATURATE|A_ONE<br><br>
			<d style="color:#ffffff4d">// Constants used by BlendCombine</d><br>
			<d>RGB_ADD</d>, <d>A_ADD</d>, <d>ADD</d> = RGB_ADD|A_ADD<br>
			<d>RGB_SUBTRACT</d>, <d>A_SUBTRACT</d>, <d>SUBTRACT</d> = RGB_SUBTRACT|A_SUBTRACT<br>
			<d>RGB_REVERSE_SUBTRACT</d>, <d>A_REVERSE_SUBTRACT</d><br>
			<d>REVERSE_SUBTRACT</d> = RGB_REVERSE_SUBTRACT|A_REVERSE_SUBTRACT<br>
			<d>RGB_MIN</d>, <d>A_MIN</d>, <d>MIN</d> = RGB_MIN|A_MIN<br>
			<d>RGB_MAX</d>, <d>A_MAX</d>, <d>MAX</d> = RGB_MAX|A_MAX<br><br>
			<d style="color:#ffffff4d">// Constants used by TextureOptions</d><br>
			<d>UPSCALE_PIXELATED</d>, <d>DOWNSCALE_PIXELATED</d>, <d>DOWNSCALE_MIPMAP_NEAREST</d><br>
			<d>PIXELATED</d> = UPSCALE_PIXELATED|DOWNSCALE_PIXELATED|DOWNSCALE_MIPMAP_NEAREST<br>
			<d>MIPMAPS</d><br>
			<d>REPEAT_X</d>, <d>REPEAT_Y</d>, <d>REPEAT</d> = REPEAT_X|REPEAT_Y<br>
			<d>REPEAT_MIRRORED_X</d>, <d>REPEAT_MIRRORED_Y</d><br>
			<d>REPEAT_MIRRORED</d> = REPEAT_MIRRORED_X|REPEAT_MIRRORED_Y
		</k>
	</div>
	<div id="texture">
		Construct a new uninitialised texture object. Do not use <c>new</c>.<br>
		If <c>layer == 0</c>, the texture will be a flat texture, with no concept of layers. All functions that accept a layer argument will ignore that argument.<br>
		Otherwise, the texture is a layered texture, which may hold different data on each layer.<br>
		<c>width</c> and <c>height</c> are not guaranteed to be supported for values > <c>4096</c>. Likewise <c>layers</c> for values > <c>256</c>.<br>
		Textures may use a lot of graphical memory. Consider reusing old textures instead of initialising new ones, and <c>.delete()</c> textures when you are done with them to avoid risks of GPU crashes
		<k><n>constructor</n>(width?: <t>int</t>, height?: <t>int</t>, layers?: <t>int</t>, format?: <n>valueof</n> <t refto="constants">Formats</t>, options?: <t>TextureOptions</t>)</k>
		<hr>
		Set the default <c>options</c> parameter for all future texture initialisations
		<k><n>static</n> .<m>defaultOptions</m>(options?: <t>TextureOptions</t>)</k>
	</div>
	<div id="uv">
		<k><n>type</n> <t>UV</t> = {x: <t>number</t>, y: <t>number</t>, w: <t>number</t>, h: <t>number</t>, l: <t>number</t>}</k>
		<hr>
		Create a uv. Do not use <c>new</c>.<br>
		A uv is a location within a texture, think a crop rectangle for a texture.<br>
		Arguments default to <c>uv(0, 0, 1, 1, 0)</c>, i.e, a square from the bottom-left (0, 0) with size (1, 1) (= the whole texture) at layer 0 (the default layer for most textures)
		<k><n>constructor</n>(x?: <t>number</t>, y?: <t>number</t>, w?: <t>number</t>, h?: <t>number</t>, layer?: <t>number</t>) -> <t>UV</t></k>
		<hr>
		Create a new uv as a sub-rect of another, imagining (0, 0) to be the bottom left of the reference uv and (1, 1) to be the top right
		<k>.<m>sub</m>(x?: <t>number</t>, y?: <t>number</t>, w?: <t>number</t>, h?: <t>number</t>) -> <t>UV</t></k>
	</div>
	<div id="mesh">
		Construct a new mesh. Do not use <c>new</c>.<br>
		Unlike textures, meshes use entirely CPU memory, exactly 64 bytes per sprite they contain. That means a mesh with 1,000,000 sprites will take up approximately 64MB of CPU memory while it is being built up until it is consumed (either with <c>mesh.upload()</c> or <c>(Target).draw(mesh)</c>)
		<k><n>constructor</n>()</k>
		<hr>
		These arguments are used by most of <c>Mesh</c>'s methods
		<k><n>arguments</n> <d>SpriteParams</d> = (uv?: <t>UV</t>, effect?: <t>number</t>, r?: <t>number</t>, g?: <t>number</t>, b?: <t>number</t>, a?: <t>number</t>)</k>
		<hr>
		Construct a mesh consisting of a single sprite, optionally from a rectangle or 3x2 matrix.<br>This is a convenience function that is also usually more performant than its longer form
		<k><n>static</n> .<m>single</m>(...<d>SpriteParams</d>) -> <t>Mesh</t><br>
		<n>static</n> .<m>singleRect</m>(x: <t>number</t>, y: <t>number</t>, w: <t>number</t>, h: <t>number</t>, ...<d>SpriteParams</d>) -> <t>Mesh</t><br>
		<n>static</n> .<m>singleMat</m>(a: <t>number</t>, b: <t>number</t>, c: <t>number</t>, d: <t>number</t>, e: <t>number</t>, f: <t>number</t>, ...<d>SpriteParams</d>) -> <t>Mesh</t></k>
		<hr>
	</div>
	<div id="target"></div>
	<div id="transformable"></div>
	<div id="shader"></div>
	<div id="blend"></div>
</div>
<script>
	let docsCurrent = docs.children.exports, docsCurrentH2 = docs.firstElementChild
	docsCurrent.style.display = 'block'; docsCurrentH2.id = 'docsselected'
	for(const t of document.querySelectorAll('[refto]')){
		const node = document.getElementById(t.getAttribute('refto'))
		if(t.parentElement == docs) node.h2 = t
		t.onclick = () => {
			if(node.parentElement != docs) return node.scrollIntoView()
			docsCurrent.style.display = ''
			;(docsCurrent = node).style.display = 'block'
			if(node.h2){
				docsselected.id = ''
				node.h2.id = 'docsselected'
			}		
		}
	}
	for(const n of document.querySelectorAll('[node]')){
		const id = n.getAttribute('node')
		n.node = document.getElementById(id)
		n.onclick = () => {selected.node.hidden=true;selected.id='';n.id='selected';n.node.hidden=false;history.replaceState({},'','#'+id)}
		if(id == location.hash.slice(1)) n.onclick()
	}
	document.body.insertAdjacentElement('beforebegin', document.querySelector('nav'))
	const syntaxes = {
		html: [
			[/<script/yi, 'color:#2ae', 'scripttag'],
			[/<[\w-]+/y, 'color:#2ae', 'tag'],
			[/<\/[\w-]+>/y, 'color: #2ae']
		],
		tag: [
			'color:red',
			[/[\w-]+=/y, null, 'prop'],
			[/[\w-]+/y, null, 'prop'],
			['>', 'color:#2ae', 'html']
		],
		scripttag: [
			'color:red',
			[/[\w-]+=/y, null, 'scriptprop'],
			[/[\w-]+/y, null, 'scriptprop'],
			['>', 'color:#2ae', 'js']
		],
		prop: [ [/('[^']*'|"[^"]*"|[^\s>]+)/, 'color:#ea2', 'tag'] ],
		scriptprop: [ [/('[^']*'|"[^"]*"|[^\s>]+)/, 'color:#ea2', 'scripttag'] ],
		js: [
			[/(let|var|const|function|class|extends|static|if|while|for|else|do|switch|case|default|continue|break|return|yield|await|void|throw|new)(?![\w$])/y, 'color:#e52;font-weight:700'],
			[/[\w$]+(?=\()/y, 'color:#dd8'],
			[/\.[\w$]+(?![(\w$])/y, 'color:#bbf'],
			[/<\/script>/y, 'color: #2ae', 'html'],
			[/('([^']|\\.)*'|"([^"]|\\.)*")/y, 'color:#ea2'],
			[/\d[\d_]*(\.[_\d]*)?(e[+-]?[\d_]+)?|\.\d+(e[+-]?[\d_]+)?|[+-]?Infinity|NaN|null|undefined/y, 'color:#ae2'],
			[/[\w$]+(?![(\w$])/y, 'color:#ccc'],
			[/\/\/.*|\/\*([^*]*|\*(?!\/))\*\/|\.\.\.(?=\s*[)}\],;\n]|\s*$)/y, 'opacity:.3'],
			['`', 'color: #ea2', 'jsstring']
		],
		jsstring: [
			'color: #ea2',
			[/\$\{/y, 'color: #ea2', 'js2'],
			['`', 'color: #ea2', 'js']
		]
	}
	const lib = fetch('./uv.min.js').then(a => a.text())
	sandbox.oncompile = src => lib.then(t => {
		sandboxi.srcdoc = '<div id=errors style="color:red;font:700 16px monospace;white-space:pre-wrap;pointer-events:none;touch-action:none;position:absolute;bottom:8px"></div><script>"use strict";addEventListener("error",onunhandledrejection=console.warn=console.error=e=>{errors.append((e.message||e.reason||e)+"\\n");errors.childNodes.length>5&&errors.childNodes[0].remove();e.preventDefault?.()});'+t+'<\/script><script>'+src.replace(/<\/script>/g,'<\\/script>') + '<\/script>'
	})
	syntaxes.js2 = [[/\}/y, 'color: #ea2', 'jsstring'], ...syntaxes.js]
	for(const c of document.getElementsByTagName('code-area'))
		c.setPatterns(syntaxes, c.getAttribute('lang')),c.value = c.textContent.trim()
</script>
</html>